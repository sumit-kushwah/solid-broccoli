#include <bits/stdc++.h>
#include <unordered_map>

using namespace std;

class Solution
{
public:
  // write your function code here

  void bfs(vector<vector<char>>& grid, int r, int c) {
    queue<pair<int, int> > q;
    q.push({r, c});
    grid[r][c] = '2';
    while(!q.empty()) {
      pair<int, int> p = q.front();
      q.pop();
      
      int x = p.first;
      int y = p.second;
      
      if (x - 1 >= 0 && grid[x - 1][y] == '1') {
        q.push({x - 1, y});
        grid[x - 1][y] = '2';
      }
      if (y + 1 < grid[0].size() && grid[x][y + 1] == '1') {
        q.push({x, y + 1});
        grid[x][y + 1] = '2';
      }
      if (x + 1 < grid.size() && grid[x + 1][y] == '1') {
        q.push({x + 1, y});
        grid[x + 1][y] = '2';
      }
      if (y - 1 >= 0 && grid[x][y - 1] == '1') {
        q.push({x, y - 1});
        grid[x][y - 1] = '2';
      }
    }
  }

  void dfs(vector<vector<char>>& grid, int r, int c) {
    stack<pair<int, int> > st;
    st.push({r, c});
    while(!st.empty()) {
      pair<int, int> p = st.top();
      
      int x = p.first;
      int y = p.second;
      grid[x][y] = '2';
      if (x - 1 >= 0 && grid[x - 1][y] == '1') {
        st.push({x - 1, y});
        
        continue;
      }
      if (y + 1 < grid[0].size() && grid[x][y + 1] == '1') {
        st.push({x, y + 1});
        
        continue;
      }
      if (x + 1 < grid.size() && grid[x + 1][y] == '1') {
        st.push({x + 1, y});
        
        continue;
      }
      if (y - 1 >= 0 && grid[x][y - 1] == '1') {
        st.push({x, y - 1});
        
        continue;
      }

      st.pop();
    }
  }

  int numIslands(vector<vector<char>>& grid) {
    int ans = 0;
    for (int i = 0; i < grid.size(); i++) {
      for (int j = 0; j < grid[i].size(); j++) {
        if (grid[i][j] == '1') {
          ans++;
          dfs(grid, i, j);
          printGraph(grid);
          cout << endl;
        }
      }
    } 
    return ans;
  }

  void printGraph(vector<vector<char>>& grid) {
    for (int i = 0; i < grid.size(); i++) {
      for (int j = 0; j < grid[0].size(); j++) {
        cout << grid[i][j] << " ";
      }
      cout << endl;
    }
  }
  void run()
  {
    vector<vector<char> > grid = {
      
        {'1','1','1','1','1','0','1','1','1','1','1','1','1','1','1','0','1','0','1','1'},
        {'0','1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','0'},
        {'1','0','1','1','1','0','0','1','1','0','1','1','1','1','1','1','1','1','1','1'},
        {'1','1','1','1','0','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},
        {'1','0','0','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},
        {'1','0','1','1','1','1','1','1','0','1','1','1','0','1','1','1','0','1','1','1'},
        {'0','1','1','1','1','1','1','1','1','1','1','1','0','1','1','0','1','1','1','1'},
        {'1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','0','1','1'},
        {'1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','1','1','1','1'},
        {'1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},
        {'0','1','1','1','1','1','1','1','0','1','1','1','1','1','1','1','1','1','1','1'},
        {'1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},
        {'1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},
        {'1','1','1','1','1','0','1','1','1','1','1','1','1','0','1','1','1','1','1','1'},
        {'1','0','1','1','1','1','1','0','1','1','1','0','1','1','1','1','0','1','1','1'},
        {'1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','1','0'},
        {'1','1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','0','0'},
        {'1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},
        {'1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},
        {'1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'}
        };
    auto ans = this->numIslands(grid);
    cout << ans << endl;

  }
};

int main()
{
  Solution *s = new Solution();
  s->run();
}